#include "Dot_Matrix.h"

const unsigned char ziku_table[]={
	
0xFF,0xF7,0x80,0xF5,0xEB,0xF5,0xEB,0xC1,0x80,0xF5,0xAA,0xF6,0xAA,0xF7,0xAA,0x80,
0x8A,0xFF,0xBC,0xFF,0xBE,0xC1,0x80,0xDD,0xBE,0xDD,0xBE,0xDD,0x80,0xC1,0xBE,0xDD,/*"?",0*/



0xFF,0xFF,0xFB,0x7F,0x1B,0x7E,0xDB,0x7E,0xDB,0xBE,0xDB,0xBE,0x00,0xD0,0xDB,0xEE,
0xDB,0xD6,0xDB,0xBA,0x1B,0x7E,0xFB,0x7F,0xF8,0xFF,0x07,0x00,0x9F,0xFF,0x7F,0xFF,/*"?",2*/

0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x80,0xDD,0x7D,0xDD,0xBD,0xDD,0xFD,0xDD,0xFD,
0x01,0x80,0xDD,0xFD,0xDD,0xFD,0xDD,0xFD,0xDD,0xFD,0x01,0xE0,0xFF,0x9F,0xFF,0x7F,/*"?",3*/

0xFF,0xFF,0xC7,0xE3,0xF7,0xDD,0xF7,0xDE,0xF7,0xDE,0x77,0xDF,0x8F,0xC7,0xFF,0xFF,/*"S",4*/

0xFF,0xFF,0xE7,0xFF,0xF7,0xFF,0xF7,0xDF,0x07,0xC0,0xF7,0xDF,0xF7,0xFF,0xE7,0xFF,/*"T",5*/

0xFF,0xFF,0xF7,0xDF,0x07,0xC0,0x07,0xFF,0xFF,0xC0,0x07,0xFF,0x07,0xC0,0xF7,0xDF,/*"M",6*/

0xFF,0xFF,0xCF,0xF1,0xB7,0xEE,0x77,0xDF,0x77,0xDF,0xF7,0xDF,0xCF,0xE7,0xFF,0xFF,/*"3",7*/

0xFF,0xFF,0x8F,0xCF,0x77,0xDE,0xF7,0xDD,0xF7,0xDB,0xF7,0xD7,0x8F,0xCF,0xFF,0xFF,/*"2",8*/

0xFF,0xFF,0xEF,0xFF,0xF7,0xFF,0x17,0xFC,0x77,0xFF,0x77,0xDF,0x07,0xC0,0xF7,0xDF,/*"F",9*/

0xFF,0xFF,0xFF,0xDB,0x07,0xC0,0xEF,0xDB,0xDF,0xDB,0x3F,0xFB,0xFF,0xF8,0xFF,0xFF,/*"4",10*/

0xFF,0xFF,0x1F,0xF0,0xEF,0xEF,0xF7,0xDF,0xF7,0xDF,0xEF,0xEF,0x1F,0xF0,0xFF,0xFF,/*"0",11*/

0xFF,0xFF,0xF7,0xFF,0xC7,0xFF,0x37,0xFF,0xF7,0xC0,0xF7,0xFF,0xC7,0xFF,0xFF,0xFF,/*"7",12*/

0xFF,0xFF,0x3F,0x7F,0xBF,0xBE,0xB1,0xCF,0xB7,0xF0,0x87,0xCF,0x77,0xBF,0xF7,0x7E,
0x70,0xFF,0x17,0x80,0x77,0xDB,0x77,0xDB,0x77,0xDB,0x11,0x80,0x7F,0xFF,0x7F,0xFF,/*"?",13*/

0xFF,0xFF,0xFF,0x7F,0xFF,0x7F,0xFF,0xBF,0xFF,0xCF,0xFF,0xF3,0xFF,0xFC,0x1F,0xFF,
0xE3,0xFF,0x1D,0xFF,0xFE,0xFC,0xFF,0xF3,0xFF,0xEF,0xFF,0xDF,0xFF,0xBF,0xFF,0x7F,/*"?",14*/

0xFF,0xFF,0xEF,0x07,0xE9,0xBF,0xEE,0xDF,0xEF,0xEF,0xEF,0xF3,0x00,0xFC,0xEF,0xFF,
0xEF,0xEF,0x6F,0xEF,0x6F,0xEF,0x6F,0xC0,0x6F,0xDF,0x6F,0x9F,0xEF,0xDF,0xEF,0xFF,/*"?",15*/

0xFF,0xFF,0x7F,0xFF,0x7D,0xFF,0x7D,0xFF,0x7D,0xFF,0x01,0x00,0x7D,0xFF,0x7D,0xFF,
0x7D,0xFF,0x7D,0xFF,0x7D,0xFF,0x01,0xF0,0x7D,0xCF,0x7D,0xBF,0x7D,0x7F,0x7F,0xFF,/*"?",16*/

0xFF,0xFF,0xFF,0x7F,0xEF,0x7F,0x6B,0xBC,0x6D,0xBB,0x6F,0xD7,0x6F,0xEF,0x6F,0xD7,
0x68,0xB9,0x47,0xBE,0x2F,0x7F,0xEF,0x7C,0xE9,0x73,0xE7,0xEF,0xFF,0xDF,0xFF,0xFF,/*"?",17*/

0xFF,0xFF,0xFF,0xFE,0xFD,0xFE,0xFD,0xFE,0xCD,0xFE,0xBD,0xFE,0xFD,0xFE,0xFD,0xFE,
0x01,0x00,0xFD,0xFE,0xFD,0xFE,0x9D,0xFE,0xED,0xFE,0xFD,0xFE,0xFD,0xFE,0xFF,0xFE,/*"?",18*/

0xFF,0xFF,0xFF,0xFF,0x3F,0xFF,0x9F,0xFF,0xAF,0x01,0xB7,0xBD,0xBF,0xBD,0xBF,0xBD,
0xBF,0xBD,0xBC,0xBD,0xBB,0xBD,0xB7,0xBD,0xAF,0x01,0x1F,0xFF,0xBF,0xFF,0xFF,0xFF,/*"?",19*/


};



Gpio_Info DP_info[DP_NUMBER]={
    {D_RCC,D_GPIO,D_GPIO_PIN},
    {C_RCC,C_GPIO,C_GPIO_PIN},
    {B_RCC,B_GPIO,B_GPIO_PIN},
    {A_RCC,A_GPIO,A_GPIO_PIN},
		{G_RCC,G_GPIO,G_GPIO_PIN},
    {DI_RCC,DI_GPIO,DI_GPIO_PIN},
    {DCLK_RCC,DCLK_GPIO,DCLK_GPIO_PIN},
    {LAT_RCC,LAT_GPIO,LAT_GPIO_PIN}
};

void Dot_Matric_Gpio_Init(void)
{
    uint8_t i;
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    for(i=0;i<DP_NUMBER;i++)
    {
        RCC_APB2PeriphClockCmd( DP_info[i].rcc , ENABLE); 
        GPIO_InitStructure.GPIO_Pin = DP_info[i].pin;
        GPIO_Init(DP_info[i].gpio, &GPIO_InitStructure);
        GPIO_WriteBit(DP_info[i].gpio,DP_info[i].pin,Bit_SET);
    }
}

/******************************************************************************************
*函数名称：void ABCD_port(u8 dat)
*
*入口参数：dat
*
*出口参数：无
*
*功能说明：修改ABCD的值
*******************************************************************************************/
void ABCD_port(u8 dat)
{
	if((dat&0x01)==0x00)
		A_ONOFF(Bit_RESET);
	else A_ONOFF(Bit_SET);
	
	if((dat&0x02)==0x00)
		B_ONOFF(Bit_RESET);
	else B_ONOFF(Bit_SET);
	
	if((dat&0x04)==0x00)
		C_ONOFF(Bit_RESET);
	else C_ONOFF(Bit_SET);
	
	if((dat&0x08)==0x00)
		D_ONOFF(Bit_RESET);
	else D_ONOFF(Bit_SET);
}

void Dot_Matrix_test(void)
{
	
	u8  i,j;
	//u8 i;
	u8 data_buff;
	u8 hanzi;
//	u8 han;
	u8 shift=1;	
	
	Dot_Matric_Gpio_Init();
			
	for(shift=0;shift<16;shift++){	//一个字移位16位
			//HC595锁定输出,避免数据传输过程中，屏数据变化从而显示闪烁
			LAT_ONOFF(Bit_RESET);
			DCLK_ONOFF(Bit_RESET);
			//74HC595输出数据Hzk16
			data_buff = ziku_table[hanzi*32+shift*2+1];
			for(i=0;i<8;i++){
				if((data_buff&0x80)!=0) DI_ONOFF(Bit_SET);//DA_in_port = 1;
				else DI_ONOFF(Bit_RESET);//DA_in_port = 0;
				DCLK_ONOFF(Bit_SET);//CLK_port = 1;
				DCLK_ONOFF(Bit_RESET);//CLK_port = 0;
				data_buff <<= 1;
				}
				data_buff = ziku_table[hanzi*32+shift*2];
				for(i=0;i<8;i++)
				{
				if((data_buff&0x01)!=0) DI_ONOFF(Bit_SET);//DA_in_port = 1;
				else DI_ONOFF(Bit_RESET);//DA_in_port = 0;
				DCLK_ONOFF(Bit_SET);//CLK_port = 1;
				DCLK_ONOFF(Bit_RESET);//CLK_port = 0;
				data_buff >>= 1;
				}
			//74HC138输出控制	 
			G_ONOFF(Bit_SET);//EN_port = 1;    //关屏显示，原理为使HC138输出全为1，从而三极管截止，点阵不显示
			ABCD_port(shift);//ABCD_port = (ABCD_port & 0x0f)|(han<<4);  //HC138译码输出
			//ABCD_port(han);//ABCD_port = (ABCD_port & 0x0f)|(han<<4);  //HC138译码输出
			LAT_ONOFF(Bit_SET);//Latch_port = 1; //允许HC595数据输出到Q1-Q8端口
			G_ONOFF(Bit_RESET);//EN_port = 0;    //HC138输出有效，打开显示
			LAT_ONOFF(Bit_RESET);//Latch_port = 0;	//锁定HC595数据输出
	}
	
}
	
